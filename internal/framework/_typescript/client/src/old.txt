/// <reference types="vite/client" />

import { createBrowserHistory, type Update } from "history";
import { debounce } from "river.now/kit/debounce";
import { jsonDeepEquals } from "river.now/kit/json";
import {
	getAnchorDetailsFromEvent,
	getHrefDetails,
	getIsErrorRes,
	getIsGETRequest,
	type HrefDetails,
} from "river.now/kit/url";
import { updateHeadEls } from "./head.ts";
import type { historyInstance, historyListener } from "./history_types.ts";
import {
	getBuildIDFromResponse,
	parseFetchResponseForRedirectData,
	type RedirectData,
} from "./redirects.ts";
import {
	type GetRouteDataOutput,
	internal_RiverClientGlobal,
	type RouteErrorComponent,
} from "./river_ctx.ts";
import { isAbortError, LogError } from "./utils.ts";

////////////////////////////////////////////////////////////////////////////////
// SECTION: CORE TYPES & CONSTANTS
////////////////////////////////////////////////////////////////////////////////

const RIVER_ROUTE_CHANGE_EVENT_KEY = "river:route-change";
const STATUS_EVENT_KEY = "river:status";
const LOCATION_EVENT_KEY = "river:location";
const BUILD_ID_EVENT_KEY = "river:build-id";
const RIVER_HARD_RELOAD_QUERY_PARAM = "river_reload";
const CSS_BUNDLE_DATA_ATTR = "data-river-css-bundle";

// Describes a navigation's type and purpose.
export type NavigationType =
	| "browserHistory" // Back/forward button
	| "userNavigation" // Click or programmatic navigation
	| "revalidation" // Refreshing data for the current page
	| "redirect" // Navigation initiated by a server redirect
	| "prefetch"; // Preloading data on hover/touch

// The state of scroll position to restore.
export type ScrollState = { x: number; y: number } | { hash: string };

// Properties for initiating a navigation.
export type NavigateProps = {
	href: string;
	navigationType: NavigationType;
	scrollStateToRestore?: ScrollState;
	replace?: boolean; // Whether to replace the history entry
};

// Represents a navigation in progress.
export type NavigationControl = {
	abortController: AbortController;
	promise: Promise<NavigationResult>;
};

// The result of a completed fetch for navigation data.
type NavigationResult =
	| {
			response: Response;
			json: GetRouteDataOutput;
			props: NavigateProps;
			cssBundlePromises: Array<Promise<any>>;
			waitFnPromise: Promise<any> | undefined;
	  }
	| { response: Response; redirectData: RedirectData }
	| undefined;

// Event detail for route changes.
type RouteChangeEventDetail = {
	scrollState?: ScrollState;
};
export type RouteChangeEvent = CustomEvent<RouteChangeEventDetail>;

// Event detail for loading status changes.
export type StatusEventDetail = {
	isNavigating: boolean;
	isSubmitting: boolean;
	isRevalidating: boolean;
};
export type StatusEvent = CustomEvent<StatusEventDetail>;

// Event detail for build ID changes.
type BuildIDEventDetail = {
	oldID: string;
	newID: string;
	fromGETAction: boolean;
};
export type BuildIDEvent = CustomEvent<BuildIDEventDetail>;

type PartialWaitFnJSON = Pick<
	GetRouteDataOutput,
	| "matchedPatterns"
	| "splatValues"
	| "params"
	| "hasRootData"
	| "loadersData"
	| "importURLs"
>;

////////////////////////////////////////////////////////////////////////////////
// SECTION: NAVIGATION MANAGER CLASS
////////////////////////////////////////////////////////////////////////////////

/**
 * Manages all aspects of client-side navigation, including data fetching,
 * state management, prefetching, submissions, and history integration.
 * This class centralizes logic to ensure consistency and testability.
 */
class NavigationManager {
	// Holds all ongoing navigations (user, prefetch, etc.), keyed by href.
	private navigations = new Map<
		string,
		{ control: NavigationControl; type: NavigationType }
	>();

	// Holds ongoing form submissions, keyed by a unique identifier.
	private submissions = new Map<string, AbortController>();

	// Tracks the currently active user-initiated navigation for singular focus.
	private activeUserNavigation: string | null = null;

	// Tracks the currently active revalidation.
	private activeRevalidation: NavigationControl | null = null;

	// Debounced dispatcher for status events to prevent UI thrashing.
	private dispatchStatusEventDebounced = debounce(() => {
		const newStatus = this.getStatus();
		if (!jsonDeepEquals(this.lastStatus, newStatus)) {
			this.lastStatus = newStatus;
			window.dispatchEvent(
				new CustomEvent<StatusEventDetail>(STATUS_EVENT_KEY, {
					detail: newStatus,
				}),
			);
		}
	}, 5);
	private lastStatus: StatusEventDetail | null = null;

	// --- Public API ---

	/**
	 * Initiates a navigation, handling everything from data fetching to rendering.
	 * This is the primary method for all navigation types.
	 * @param props - The properties describing the navigation.
	 */
	public async navigate(props: NavigateProps): Promise<void> {
		this.setLoadingStatus(props.navigationType);
		const control = this.beginNavigation(props);

		try {
			const result = await control.promise;
			await this.processNavigationResult(result, control, props);
		} catch (error) {
			if (!isAbortError(error)) {
				LogError(`Navigation to ${props.href} failed`, error);
			}
			this.setLoadingStatus(props.navigationType);
		}
	}

	/**
	 * Processes a fetched navigation result, handling rendering or redirection.
	 * This is separated to allow hooks like `beforeRender`.
	 */
	public async processNavigationResult(
		result: NavigationResult,
		control: NavigationControl,
		originalProps: NavigateProps,
	): Promise<void> {
		try {
			if (!result) {
				return;
			}

			if ("redirectData" in result) {
				await this.effectuateRedirect(result.redirectData);
			} else {
				await this.completeNavigation(result);
			}
		} finally {
			// Loading status is turned off inside completeNavigation or on error.
			if (this.navigations.get(originalProps.href)?.control === control) {
				this.navigations.delete(originalProps.href);
			}
			if (this.activeUserNavigation === originalProps.href) {
				this.activeUserNavigation = null;
			}
			if (this.activeRevalidation === control) {
				this.activeRevalidation = null;
			}
			this.setLoadingStatus(originalProps.navigationType);
		}
	}

	/**
	 * Revalidates the data for the current page. Debounced to prevent rapid-fire requests.
	 */
	public revalidate = debounce(async () => {
		await this.navigate({
			href: window.location.href,
			navigationType: "revalidation",
		});
	}, 10);

	/**
	 * Handles form submissions, including data fetching, redirects, and revalidation.
	 * @param url - The submission URL.
	 * @param requestInit - The request options (method, body, etc.).
	 * @returns A result object with the submission data or an error.
	 */
	public async submit<T = any>(
		url: string | URL,
		requestInit?: RequestInit,
	): Promise<{ success: true; data: T } | { success: false; error: string }> {
		this.setLoadingStatus("submission");
		const submissionResult = await this.submitInner(url, requestInit);

		const needsRevalidation =
			!submissionResult.alreadyRevalidated && !getIsGETRequest(requestInit);
		if (needsRevalidation) {
			// Revalidation will manage its own loading status, ensuring a smooth transition
			await this.revalidate();
		}

		this.setLoadingStatus("submission");

		if (!submissionResult.success) {
			LogError(submissionResult.error);
			return { success: false, error: submissionResult.error };
		}

		try {
			const json = await submissionResult.response.json();
			return { success: true, data: json as T };
		} catch (e) {
			const errorMsg =
				e instanceof Error ? e.message : "Response parsing error";
			LogError(e);
			return { success: false, error: errorMsg };
		}
	}

	/**
	 * Begins a navigation and returns the control object. Does not complete the navigation.
	 * This is a lower-level API for use when hooks like `beforeRender` are needed.
	 */
	public beginNavigation(props: NavigateProps): NavigationControl {
		// If this is a user navigation, it takes precedence.
		if (props.navigationType === "userNavigation") {
			this.abortAllNavigationsExcept(props.href);
			this.activeUserNavigation = props.href;

			// If a prefetch for this href exists, upgrade it.
			const existing = this.navigations.get(props.href);
			if (existing?.type === "prefetch") {
				existing.type = "userNavigation";
				return existing.control;
			}
		}

		// If a revalidation is starting, abort any old one.
		if (props.navigationType === "revalidation") {
			this.activeRevalidation?.abortController.abort();
		}

		// Don't start a new navigation if a compatible one already exists.
		const existing = this.navigations.get(props.href);
		if (existing) {
			return existing.control;
		}

		const controller = new AbortController();
		const control: NavigationControl = {
			abortController: controller,
			promise: this.fetchRouteData(controller, props),
		};

		this.navigations.set(props.href, { control, type: props.navigationType });

		if (props.navigationType === "revalidation") {
			this.activeRevalidation = control;
		}

		return control;
	}

	/**
	 * Discards a navigation that was started with `beginNavigation` but should not be completed.
	 * @param href - The URL of the navigation to discard.
	 */
	public discardNavigation(href: string): void {
		const nav = this.navigations.get(href);
		if (nav) {
			nav.control.abortController.abort();
			this.navigations.delete(href);
			if (this.activeUserNavigation === href) {
				this.activeUserNavigation = null;
			}
			this.setLoadingStatus(nav.type);
		}
	}

	/**
	 * Checks if an active navigation for a given href is a prefetch.
	 * @param href The URL to check.
	 */
	public isPrefetch(href: string): boolean {
		return this.navigations.get(href)?.type === "prefetch";
	}

	/**
	 * Returns the current loading status of the navigation system.
	 */
	public getStatus(): StatusEventDetail {
		return {
			isNavigating: !!this.activeUserNavigation,
			isRevalidating: !!this.activeRevalidation,
			isSubmitting: this.submissions.size > 0,
		};
	}

	/**
	 * Returns a history listener function that correctly handles browser back/forward events.
	 */
	public getHistoryListener(): historyListener {
		// The listener itself is sync to match the 'history' library's type signature.
		// The async work is done in an IIFE so we don't block the listener.
		return (({ action, location }: Update) => {
			(async () => {
				if (location.key !== lastKnownCustomLocation.key) {
					dispatchLocationEvent();
				}

				const isPop = action === "POP";
				const isSameDoc =
					location.pathname === lastKnownCustomLocation.pathname &&
					location.search === lastKnownCustomLocation.search;

				// Save scroll state BEFORE a PUSH navigation, which is what clicking
				// an in-page hash link is. The pop handler will then read this value.
				if (!isSameDoc) {
					saveScrollState();
				}

				if (isPop) {
					if (isSameDoc) {
						// This is a hash change within the same document.
						if (location.hash) {
							// Adding or changing a hash.
							applyScrollState({ hash: location.hash.slice(1) });
						} else {
							// FIX: Removing a hash. We are returning to the state of this page
							// before the hash was added. We must restore its scroll position.
							const stored = scrollStateMapSubKey.read(location.key);
							applyScrollState(stored ?? { x: 0, y: 0 });
						}
					} else {
						// This is a navigation to a different document in the history stack.
						await this.navigate({
							href: location.pathname + location.search + location.hash,
							navigationType: "browserHistory",
							scrollStateToRestore: scrollStateMapSubKey.read(location.key),
						});
					}
				}

				lastKnownCustomLocation = location;
			})();
		}) as unknown as historyListener;
	}

	/**
	 * Used in DEV mode to re-run client loaders on HMR updates.
	 */
	public async runDevClientLoaderSetup(): Promise<void> {
		this.setLoadingStatus("revalidation");
		try {
			await setupClientLoaders();
			window.dispatchEvent(
				new CustomEvent<RouteChangeEventDetail>(RIVER_ROUTE_CHANGE_EVENT_KEY, {
					detail: {},
				}),
			);
		} finally {
			this.setLoadingStatus("revalidation");
		}
	}

	// --- Internal Logic ---

	private async fetchRouteData(
		controller: AbortController,
		props: NavigateProps,
	): Promise<NavigationResult> {
		const url = new URL(props.href, window.location.href);
		url.searchParams.set(
			"river_json",
			internal_RiverClientGlobal.get("buildID") || "1",
		);

		const { redirectData, response } = await this.handleRedirects(
			controller,
			url,
			props.navigationType === "prefetch",
		);

		if (!response || (!response.ok && response.status !== 304)) {
			throw new Error(`Fetch failed with status: ${response?.status}`);
		}

		if (redirectData?.status === "should") {
			return { response, redirectData };
		}

		const json = (await response.json()) as GetRouteDataOutput;
		if (!json) {
			throw new Error("Invalid JSON response from server.");
		}

		// Preload JS and CSS dependencies.
		const depsToPreload = (
			import.meta.env.DEV ? [...new Set(json.importURLs)] : (json.deps ?? [])
		).filter(Boolean) as Array<string>;
		this.preloadJS(depsToPreload);
		const cssBundlePromises = this.preloadCSS(
			(json.cssBundles ?? []).filter(Boolean) as Array<string>,
		);

		// Concurrently run client-side wait functions.
		const buildID = getBuildIDFromResponse(response);
		const waitFnPromise = runWaitFns(json, buildID);

		return { response, json, props, cssBundlePromises, waitFnPromise };
	}

	private async completeNavigation(
		result: Exclude<NavigationResult, { redirectData: any } | undefined>,
	): Promise<void> {
		// Handle build ID changes.
		const oldID = internal_RiverClientGlobal.get("buildID");
		const newID = getBuildIDFromResponse(result.response);
		if (newID && newID !== oldID) {
			dispatchBuildIDEvent({ newID, oldID, fromGETAction: false });
		}

		// Wait for client loaders to finish.
		const clientLoadersData = await result.waitFnPromise;
		internal_RiverClientGlobal.set("clientLoadersData", clientLoadersData);

		// Use view transitions if available and appropriate.
		const shouldUseViewTransitions =
			internal_RiverClientGlobal.get("useViewTransitions") &&
			!!document.startViewTransition &&
			result.props.navigationType !== "prefetch" &&
			result.props.navigationType !== "revalidation";

		const reRender = async () =>
			__reRenderApp({
				json: result.json,
				navigationType: result.props.navigationType,
				runHistoryOptions: result.props,
				cssBundlePromises: result.cssBundlePromises,
			});

		if (shouldUseViewTransitions) {
			const transition = document.startViewTransition(reRender);
			await transition.finished;
		} else {
			await reRender();
		}
	}

	private async submitInner(
		url: string | URL,
		requestInit?: RequestInit,
	): Promise<
		(
			| { success: true; response: Response }
			| { success: false; error: string }
		) & { alreadyRevalidated: boolean }
	> {
		const urlToUse = new URL(url, window.location.href);
		const submissionKey = urlToUse.href + (requestInit?.method || "GET");

		// Abort any previous submission to the same endpoint.
		this.submissions.get(submissionKey)?.abort();
		const controller = new AbortController();
		this.submissions.set(submissionKey, controller);

		try {
			const { redirectData, response } = await this.handleRedirects(
				controller,
				urlToUse,
				false,
				requestInit,
			);

			const oldID = internal_RiverClientGlobal.get("buildID");
			const newID = getBuildIDFromResponse(response);
			if (newID && newID !== oldID) {
				dispatchBuildIDEvent({
					newID,
					oldID,
					fromGETAction: getIsGETRequest(requestInit),
				});
			}

			const redirected = redirectData?.status === "did";

			if (!response || getIsErrorRes(response) || !response.ok) {
				return {
					success: false,
					error: `Submission failed: ${response?.status}`,
					alreadyRevalidated: redirected,
				};
			}

			return { success: true, response, alreadyRevalidated: redirected };
		} catch (error) {
			if (isAbortError(error)) {
				return { success: false, error: "Aborted", alreadyRevalidated: false };
			}
			LogError(error);
			return {
				success: false,
				error:
					error instanceof Error ? error.message : "Unknown submission error",
				alreadyRevalidated: false,
			};
		} finally {
			this.submissions.delete(submissionKey);
		}
	}

	private async handleRedirects(
		abortController: AbortController,
		url: URL,
		isPrefetch: boolean,
		requestInit?: RequestInit,
	) {
		const headers = new Headers(requestInit?.headers);
		headers.set("X-Accepts-Client-Redirect", "1");

		const finalRequestInit: RequestInit = {
			...requestInit,
			signal: abortController.signal,
			headers,
		};

		try {
			const response = await fetch(url, finalRequestInit);
			const redirectData = parseFetchResponseForRedirectData(
				finalRequestInit,
				response,
			);

			// If it's a prefetch, we don't act on the redirect, just return the data.
			if (isPrefetch || !redirectData || redirectData.status === "did") {
				return { redirectData, response };
			}

			// Otherwise, perform the redirect.
			const newRedirectData = await this.effectuateRedirect(redirectData);
			return { redirectData: newRedirectData, response };
		} catch (error) {
			// On network errors during GET, a hard reload is a safe fallback.
			if (!isAbortError(error) && getIsGETRequest(requestInit) && !isPrefetch) {
				window.location.href = url.href;
			}
			throw error; // Re-throw for the caller to handle.
		}
	}

	private async effectuateRedirect(
		redirectData: RedirectData,
	): Promise<RedirectData | null> {
		if (redirectData.status !== "should") {
			return null;
		}

		if (redirectData.shouldRedirectStrategy === "hard") {
			if (!redirectData.hrefDetails.isHTTP) {
				return null;
			}
			let targetUrl = redirectData.href;
			if (redirectData.hrefDetails.isInternal) {
				const url = new URL(targetUrl, window.location.href);
				url.searchParams.set(
					RIVER_HARD_RELOAD_QUERY_PARAM,
					redirectData.latestBuildID,
				);
				targetUrl = url.href;
			}
			window.location.href = targetUrl;
			return { ...redirectData, status: "did" };
		}

		if (redirectData.shouldRedirectStrategy === "soft") {
			await this.navigate({
				href: redirectData.href,
				navigationType: "redirect",
			});
			return { ...redirectData, status: "did" };
		}

		return null;
	}

	private abortAllNavigationsExcept(excludeHref?: string): void {
		for (const [href, nav] of this.navigations.entries()) {
			if (href !== excludeHref) {
				nav.control.abortController.abort();
				this.navigations.delete(href);
			}
		}
		if (this.activeRevalidation) {
			this.activeRevalidation.abortController.abort();
			this.activeRevalidation = null;
		}
	}

	private setLoadingStatus(type: NavigationType | "submission") {
		// We don't show a global loading indicator for prefetches.
		if (type === "prefetch") {
			return;
		}

		// The actual status is derived from state, but this call triggers the debounced event.
		this.dispatchStatusEventDebounced();
	}

	private preloadJS(deps: Array<string> = []): void {
		for (const dep of deps) {
			const safeDep = dep.split("?")[0];
			if (
				dep &&
				safeDep &&
				!document.querySelector(`link[href*="${CSS.escape(safeDep)}"]`)
			) {
				const link = document.createElement("link");
				link.rel = "modulepreload";
				link.href = resolvePublicHref(dep);
				document.head.appendChild(link);
			}
		}
	}

	private preloadCSS(bundles: Array<string> = []): Array<Promise<any>> {
		const promises: Array<Promise<any>> = [];
		for (const bundle of bundles) {
			const href = resolvePublicHref(bundle);
			if (
				bundle &&
				href &&
				!document.querySelector(`link[href="${CSS.escape(href)}"]`)
			) {
				const link = document.createElement("link");
				link.rel = "preload";
				link.as = "style";
				link.href = href;

				promises.push(
					new Promise((resolve, reject) => {
						link.onload = resolve;
						link.onerror = reject;
					}),
				);

				document.head.appendChild(link);
			}
		}
		return promises;
	}
}

////////////////////////////////////////////////////////////////////////////////
// SECTION: SINGLETON INSTANCE & PUBLIC API WRAPPERS
////////////////////////////////////////////////////////////////////////////////

export const navigationManager = new NavigationManager();

// --- Public Functions ---

export async function navigate(href: string, options?: { replace?: boolean }) {
	await navigationManager.navigate({
		href,
		navigationType: "userNavigation",
		replace: options?.replace,
	});
}

export const revalidate = () => navigationManager.revalidate();

export async function submit<T = any>(
	url: string | URL,
	requestInit?: RequestInit,
) {
	return navigationManager.submit<T>(url, requestInit);
}

export function getStatus(): StatusEventDetail {
	return navigationManager.getStatus();
}

type LinkOnClickCallbacks<E extends Event> = {
	beforeBegin?: (event: E) => void | Promise<void>;
	beforeRender?: (
		event: E,
		data?: GetRouteDataOutput,
	) => undefined | Promise<boolean | undefined>;
	afterRender?: (event: E) => void | Promise<void>;
};

export function makeLinkOnClickFn<E extends Event>(
	callbacks: LinkOnClickCallbacks<E>,
) {
	return async (e: E) => {
		const anchorDetails = getAnchorDetailsFromEvent(e as unknown as MouseEvent);
		if (
			e.defaultPrevented ||
			!anchorDetails?.isEligibleForDefaultPrevention ||
			!anchorDetails?.isInternal
		) {
			return;
		}

		if (isJustAHashChange(anchorDetails)) {
			saveScrollState();
			return;
		}

		e.preventDefault();
		await callbacks.beforeBegin?.(e);

		const navProps: NavigateProps = {
			href: anchorDetails.anchor.href,
			navigationType: "userNavigation",
		};
		const control = navigationManager.beginNavigation(navProps);

		try {
			const result = await control.promise;

			if (!result) {
				return;
			}

			// FIX: Re-introduce the beforeRender hook
			const beforeRenderResult = await callbacks.beforeRender?.(
				e,
				"json" in result ? result.json : undefined,
			);
			if (beforeRenderResult === false) {
				navigationManager.discardNavigation(navProps.href);
				return;
			}

			await navigationManager.processNavigationResult(
				result,
				control,
				navProps,
			);
			await callbacks.afterRender?.(e);
		} catch (error) {
			if (!isAbortError(error)) {
				LogError("Link click navigation failed", error);
			}
			navigationManager.discardNavigation(navProps.href);
		}
	};
}

type GetPrefetchHandlersInput<E extends Event> = LinkOnClickCallbacks<E> & {
	href: string;
	delayMs?: number;
};

export function getPrefetchHandlers<E extends Event>(
	input: GetPrefetchHandlersInput<E>,
) {
	const hrefDetails = getHrefDetails(input.href);
	if (
		!hrefDetails.isHTTP ||
		!hrefDetails.relativeURL ||
		hrefDetails.isExternal
	) {
		return;
	}

	let timer: number | undefined;

	const prefetch = () => {
		navigationManager.beginNavigation({
			href: hrefDetails.relativeURL,
			navigationType: "prefetch",
		});
	};

	const start = () => {
		clearTimeout(timer);
		if (isSamePage(hrefDetails)) {
			return;
		}
		timer = window.setTimeout(() => prefetch(), input.delayMs ?? 100);
	};

	// Correctly cancels the prefetch if the user mouses away.
	const stop = () => {
		clearTimeout(timer);
		// Only cancel if it's still a prefetch and hasn't been upgraded by a click.
		if (navigationManager.isPrefetch(hrefDetails.relativeURL)) {
			navigationManager.discardNavigation(hrefDetails.relativeURL);
		}
	};

	const onClick = async (e: E) => {
		if (e.defaultPrevented) {
			return;
		}

		const anchorDetails = getAnchorDetailsFromEvent(e as unknown as MouseEvent);
		if (
			!anchorDetails?.isEligibleForDefaultPrevention ||
			!anchorDetails.isInternal
		) {
			return;
		}

		if (isJustAHashChange(anchorDetails)) {
			saveScrollState();
			return;
		}

		e.preventDefault();
		clearTimeout(timer);

		await input.beforeBegin?.(e);

		const navProps: NavigateProps = {
			href: hrefDetails.relativeURL,
			navigationType: "userNavigation",
		};

		// This will find and upgrade the existing prefetch.
		const control = navigationManager.beginNavigation(navProps);

		try {
			const result = await control.promise;
			if (!result) {
				return;
			}

			const beforeRenderResult = await input.beforeRender?.(
				e,
				"json" in result ? result.json : undefined,
			);
			if (beforeRenderResult === false) {
				navigationManager.discardNavigation(navProps.href);
				return;
			}

			await navigationManager.processNavigationResult(
				result,
				control,
				navProps,
			);
			await input.afterRender?.(e);
		} catch (error) {
			if (!isAbortError(error)) {
				LogError("Prefetched navigation failed on click", error);
			}
			navigationManager.discardNavigation(navProps.href);
		}
	};

	return { ...hrefDetails, start, stop, onClick };
}

////////////////////////////////////////////////////////////////////////////////
// SECTION: INITIALIZATION & HISTORY
////////////////////////////////////////////////////////////////////////////////

let __customHistory: historyInstance;
let lastKnownCustomLocation: (typeof __customHistory)["location"];

export function getHistoryInstance(): historyInstance {
	if (!__customHistory) {
		__customHistory = createBrowserHistory() as unknown as historyInstance;
		lastKnownCustomLocation = __customHistory.location;
	}
	return __customHistory;
}

export function getRootEl() {
	return document.getElementById("river-root") as HTMLDivElement;
}

export async function initClient(
	renderFn: () => void,
	options?: {
		defaultErrorBoundary?: RouteErrorComponent;
		useViewTransitions?: boolean;
	},
) {
	// Set global options
	internal_RiverClientGlobal.set(
		"defaultErrorBoundary",
		options?.defaultErrorBoundary ?? defaultErrorBoundary,
	);
	if (options?.useViewTransitions) {
		internal_RiverClientGlobal.set("useViewTransitions", true);
	}

	// Initialize history and listen for changes
	const history = getHistoryInstance();
	history.listen(navigationManager.getHistoryListener());
	if (window.history.scrollRestoration) {
		window.history.scrollRestoration = "manual";
	}

	// Clean up URL after a hard reload redirect
	const url = new URL(window.location.href);
	if (url.searchParams.has(RIVER_HARD_RELOAD_QUERY_PARAM)) {
		url.searchParams.delete(RIVER_HARD_RELOAD_QUERY_PARAM);
		history.replace(url.href);
	}

	// Initial setup
	await handleComponents(internal_RiverClientGlobal.get("importURLs"));
	await setupClientLoaders();
	renderFn();

	checkIfShouldScrollPostRefresh();

	window.addEventListener(
		"touchstart",
		() => internal_RiverClientGlobal.set("isTouchDevice", true),
		{ once: true },
	);
}

////////////////////////////////////////////////////////////////////////////////
// SECTION: DOM, RENDERING & STATE HELPERS
////////////////////////////////////////////////////////////////////////////////

type RerenderAppProps = {
	json: GetRouteDataOutput;
	navigationType: NavigationType;
	runHistoryOptions?: {
		href: string;
		scrollStateToRestore?: ScrollState;
		replace?: boolean;
	};
	cssBundlePromises: Array<any>;
};

async function __reRenderApp({
	json,
	navigationType,
	runHistoryOptions,
	cssBundlePromises,
}: RerenderAppProps) {
	// Set global state from the server response
	const keysToSet = [
		"outermostError",
		"outermostErrorIdx",
		"errorExportKey",
		"matchedPatterns",
		"loadersData",
		"importURLs",
		"exportKeys",
		"hasRootData",
		"params",
		"splatValues",
	] as const;
	for (const key of keysToSet) {
		internal_RiverClientGlobal.set(key, json[key]);
	}

	await handleComponents(json.importURLs);

	let scrollStateToDispatch: ScrollState | undefined;

	// Update browser history and determine scroll behavior
	if (runHistoryOptions) {
		const { href, scrollStateToRestore, replace } = runHistoryOptions;
		const hash = href.split("#")[1];

		if (navigationType === "userNavigation" || navigationType === "redirect") {
			if (new URL(href, window.location.href).href !== window.location.href) {
				getHistoryInstance()[replace ? "replace" : "push"](href);
			}
			scrollStateToDispatch = hash ? { hash } : { x: 0, y: 0 };
		} else if (navigationType === "browserHistory") {
			scrollStateToDispatch =
				scrollStateToRestore ?? (hash ? { hash } : undefined);
		}
	}

	// Update document title
	const tempTxt = document.createElement("textarea");
	tempTxt.innerHTML = json.title?.dangerousInnerHTML ?? "";
	if (document.title !== tempTxt.value) {
		document.title = tempTxt.value;
	}

	// Wait for CSS to be ready before dispatching the final event
	await Promise.all(cssBundlePromises).catch((err) =>
		LogError("CSS preload failed", err),
	);

	// Dispatch the route change event for components to re-render
	window.dispatchEvent(
		new CustomEvent<RouteChangeEventDetail>(RIVER_ROUTE_CHANGE_EVENT_KEY, {
			detail: { scrollState: scrollStateToDispatch },
		}),
	);

	// Update head elements
	window.requestAnimationFrame(() => {
		for (const bundle of json.cssBundles ?? []) {
			const href = resolvePublicHref(bundle);
			if (href && !document.querySelector(`link[href="${CSS.escape(href)}"]`)) {
				const newLink = document.createElement("link");
				newLink.rel = "stylesheet";
				newLink.href = href;
				newLink.setAttribute(CSS_BUNDLE_DATA_ATTR, bundle);
				document.head.appendChild(newLink);
			}
		}
		updateHeadEls("meta", json.metaHeadEls ?? []);
		updateHeadEls("rest", json.restHeadEls ?? []);
	});
}

async function handleComponents(importURLs: Array<string>) {
	const modulesMap = await importNewComponentsAndGetModulesMap(importURLs);
	const originalImportURLs = internal_RiverClientGlobal.get("importURLs");
	const exportKeys = internal_RiverClientGlobal.get("exportKeys") ?? [];

	internal_RiverClientGlobal.set(
		"activeComponents",
		originalImportURLs.map(
			(url, i) => modulesMap.get(url)?.[exportKeys[i] ?? "default"] ?? null,
		),
	);

	// Setup error boundary component
	const errorIdx = internal_RiverClientGlobal.get("outermostErrorIdx");
	if (errorIdx != null) {
		const errorURL = originalImportURLs[errorIdx];
		const errorModule = errorURL ? modulesMap.get(errorURL) : undefined;
		const errorKey = internal_RiverClientGlobal.get("errorExportKey");
		const errorComp =
			errorKey && errorModule ? errorModule[errorKey] : undefined;
		internal_RiverClientGlobal.set(
			"activeErrorBoundary",
			errorComp ?? internal_RiverClientGlobal.get("defaultErrorBoundary"),
		);
	}
}

async function runWaitFns(
	json: PartialWaitFnJSON,
	buildID: string,
): Promise<Array<any>> {
	await importNewComponentsAndGetModulesMap(json.importURLs ?? []);
	const patternToWaitFnMap =
		internal_RiverClientGlobal.get("patternToWaitFnMap");

	return Promise.all(
		(json.matchedPatterns ?? []).map((pattern, i) => {
			const waitFn = patternToWaitFnMap[pattern];
			if (waitFn) {
				const props = resolveWaitFnPropsFromJSON(json, buildID, i);
				return waitFn(props);
			}
			return Promise.resolve();
		}),
	);
}

async function setupClientLoaders() {
	const clientLoadersData = await runWaitFns(
		{
			hasRootData: internal_RiverClientGlobal.get("hasRootData"),
			importURLs: internal_RiverClientGlobal.get("importURLs"),
			loadersData: internal_RiverClientGlobal.get("loadersData"),
			matchedPatterns: internal_RiverClientGlobal.get("matchedPatterns"),
			params: internal_RiverClientGlobal.get("params"),
			splatValues: internal_RiverClientGlobal.get("splatValues"),
		},
		internal_RiverClientGlobal.get("buildID"),
	);
	internal_RiverClientGlobal.set("clientLoadersData", clientLoadersData);
}

////////////////////////////////////////////////////////////////////////////////
// SECTION: UTILITY FUNCTIONS
////////////////////////////////////////////////////////////////////////////////

function isJustAHashChange(
	anchorDetails: ReturnType<typeof getAnchorDetailsFromEvent>,
): boolean {
	if (!anchorDetails) {
		return false;
	}
	const { pathname, search, hash } = new URL(
		anchorDetails.anchor.href,
		window.location.href,
	);
	return (
		!!hash &&
		pathname === window.location.pathname &&
		search === window.location.search
	);
}

function isSamePage(hrefDetails: HrefDetails): boolean {
	if (!hrefDetails.isHTTP) {
		return false;
	}
	const current = new URL(window.location.href);
	const target = hrefDetails.url;
	return (
		current.pathname === target.pathname && current.search === target.search
	);
}

function resolvePublicHref(relativeHref: string): string {
	let baseURL =
		internal_RiverClientGlobal.get("viteDevURL") ||
		internal_RiverClientGlobal.get("publicPathPrefix");
	baseURL = baseURL.endsWith("/") ? baseURL.slice(0, -1) : baseURL;
	const final = relativeHref.startsWith("/")
		? baseURL + relativeHref
		: `${baseURL}/${relativeHref}`;
	return import.meta.env.DEV ? `${final}?river_dev=1` : final;
}

async function importNewComponentsAndGetModulesMap(
	importURLs: Array<string>,
): Promise<Map<string, any>> {
	const dedupedURLs = [...new Set(importURLs?.filter(Boolean) ?? [])];
	const modules = await Promise.all(
		dedupedURLs.map(
			(url) => import(/* @vite-ignore */ resolvePublicHref(url as string)),
		),
	);
	return new Map(dedupedURLs.map((url, i) => [url, modules[i]]));
}

function resolveWaitFnPropsFromJSON(
	json: PartialWaitFnJSON,
	buildID: string,
	idx: number,
) {
	return {
		buildID: buildID,
		matchedPatterns: json.matchedPatterns || [],
		splatValues: json.splatValues || [],
		params: json.params || {},
		rootData: json.hasRootData ? json.loadersData[0] : null,
		loaderData: json.loadersData[idx],
	};
}

const defaultErrorBoundary: RouteErrorComponent = (props: { error: string }) =>
	"Route Error: " + props.error;

// --- Scroll Restoration ---
const scrollStateMapKey = "__river__scrollStateMap";
const getScrollStateMap = (): Map<string, ScrollState> =>
	new Map(JSON.parse(sessionStorage.getItem(scrollStateMapKey) || "[]"));
const setScrollStateMap = (map: Map<string, ScrollState>) =>
	sessionStorage.setItem(
		scrollStateMapKey,
		JSON.stringify(Array.from(map.entries())),
	);
const scrollStateMapSubKey = {
	read: (key: string) => getScrollStateMap().get(key),
	set: (key: string, value: ScrollState) => {
		const map = getScrollStateMap();
		map.set(key, value);
		if (map.size > 50) {
			const oldestKey = map.keys().next().value as string | undefined;
			if (oldestKey) {
				map.delete(oldestKey);
			}
		}
		setScrollStateMap(map);
	},
};

function saveScrollState() {
	scrollStateMapSubKey.set(lastKnownCustomLocation.key, {
		x: window.scrollX,
		y: window.scrollY,
	});
}

export function applyScrollState(state?: ScrollState) {
	requestAnimationFrame(() => {
		if (!state) {
			const id = window.location.hash.slice(1);
			if (id) {
				document.getElementById(id)?.scrollIntoView();
			}
			return;
		}
		if ("hash" in state && state.hash) {
			document.getElementById(state.hash)?.scrollIntoView();
		} else if ("x" in state) {
			window.scrollTo(state.x, state.y);
		}
	});
}

const pageRefreshScrollStateKey = "__river__pageRefreshScrollState";
window.addEventListener("beforeunload", () =>
	sessionStorage.setItem(
		pageRefreshScrollStateKey,
		JSON.stringify({
			x: window.scrollX,
			y: window.scrollY,
			href: window.location.href,
			unix: Date.now(),
		}),
	),
);
function checkIfShouldScrollPostRefresh() {
	const item = sessionStorage.getItem(pageRefreshScrollStateKey);
	if (item) {
		sessionStorage.removeItem(pageRefreshScrollStateKey);
		const state = JSON.parse(item);
		if (state.href === window.location.href && Date.now() - state.unix < 5000) {
			applyScrollState(state);
		}
	}
}

// --- Event Utils ---
type CleanupFunction = () => void;
function makeListenerAdder<T>(key: string) {
	return (listener: (event: CustomEvent<T>) => void): CleanupFunction => {
		const eventListener = listener as EventListener;
		window.addEventListener(key, eventListener);
		return () => window.removeEventListener(key, eventListener);
	};
}

export const addRouteChangeListener = makeListenerAdder<RouteChangeEventDetail>(
	RIVER_ROUTE_CHANGE_EVENT_KEY,
);
export const addStatusListener =
	makeListenerAdder<StatusEventDetail>(STATUS_EVENT_KEY);
export const addLocationListener = makeListenerAdder<void>(LOCATION_EVENT_KEY);
export const addBuildIDListener =
	makeListenerAdder<BuildIDEventDetail>(BUILD_ID_EVENT_KEY);

function dispatchLocationEvent() {
	window.dispatchEvent(new CustomEvent(LOCATION_EVENT_KEY));
}

export function getLocation() {
	return {
		pathname: window.location.pathname,
		search: window.location.search,
		hash: window.location.hash,
	};
}

function dispatchBuildIDEvent(detail: BuildIDEventDetail) {
	internal_RiverClientGlobal.set("buildID", detail.newID);
	window.dispatchEvent(new CustomEvent(BUILD_ID_EVENT_KEY, { detail }));
}

export function getBuildID() {
	return internal_RiverClientGlobal.get("buildID");
}
