/**********************************************************************
/ Generated by tsgen. DO NOT EDIT.
/*********************************************************************/

/**********************************************************************
/ Collection:
/*********************************************************************/

const routes = [
	{
		_type: "loader",
		isRootData: true,
		pattern: "/",
		phantomOutputType: null as unknown as RootData,
	},
	{
		_type: "loader",
		isSplat: true,
		pattern: "/*",
		phantomOutputType: null as unknown as DetailedPage,
	},
	{
		_type: "loader",
		params: ["dyn"],
		pattern: "/__/:dyn",
		phantomOutputType: null,
	},
	{
		_type: "loader",
		pattern: "/_index",
		phantomOutputType: null as unknown as string,
	},
] as const;

/**********************************************************************
/ Ad Hoc Types:
/*********************************************************************/

export type DetailedPage = {
	Title?: string;
	Description?: string;
	Date?: string;
	Content?: string;
	URL?: string;
	IsFolder?: boolean;
	Sitemap: Array<SitemapItem>;
	IndexSitemap: Array<SitemapItem>;
	BackItem: string;
};

export type RootData = {
	LatestVersion: string;
};

export type Sitemap = Array<SitemapItem>;

export type SitemapItem = {
	title: string;
	url: string;
	isActive?: boolean;
};

/**********************************************************************
/ Extra TS Code:
/*********************************************************************/

export type RiverLoader = Extract<(typeof routes)[number], { _type: "loader" }>;
export type RiverLoaders = { [K in RiverLoaderPattern]: Extract<RiverLoader, { pattern: K }>; };
export type RiverLoaderPattern = RiverLoader["pattern"];
export type RiverLoaderOutput<T extends RiverLoaderPattern> = Extract<RiverLoader, { pattern: T }>["phantomOutputType"];

export type RiverQuery = Extract<(typeof routes)[number], { _type: "query" }>;
export type RiverQueries = { [K in RiverQueryPattern]: Extract<RiverQuery, { pattern: K }>; };
export type RiverQueryPattern = RiverQuery["pattern"];
export type RiverQueryInput<T extends RiverQueryPattern> = Extract<RiverQuery, { pattern: T }>["phantomInputType"];
export type RiverQueryOutput<T extends RiverQueryPattern> = Extract<RiverQuery, { pattern: T }>["phantomOutputType"];

export type RiverMutation = Extract<(typeof routes)[number], { _type: "mutation" }>;
export type RiverMutations = { [K in RiverMutationPattern]: Extract<RiverMutation, { pattern: K }>; };
export type RiverMutationPattern = RiverMutation["pattern"];
export type RiverMutationInput<T extends RiverMutationPattern> = Extract<RiverMutation, { pattern: T }>["phantomInputType"];
export type RiverMutationOutput<T extends RiverMutationPattern> = Extract<RiverMutation, { pattern: T }>["phantomOutputType"];

import type { SharedBase, WithOptionalInput } from "river.now/client";

export const apiConfig = {
	actionsRouterMountRoot: "/api/",
	actionsDynamicRune: ":",
	actionsSplatRune: "*",
	loadersDynamicRune: ":",
	loadersSplatRune: "*",
	loadersExplicitIndexSegment: "_index",
} as const;

export type RiverMutationMethod<T extends RiverMutationPattern> =
	Extract<RiverMutation, { pattern: T }> extends { method: infer M }
		? M extends string
			? M
			: "POST"
		: "POST";

export type BaseQueryProps<P extends RiverQueryPattern> = SharedBase<
	P,
	RiverFunction
>;

export type BaseMutationProps<P extends RiverMutationPattern> = SharedBase<
	P,
	RiverFunction
> &
	(RiverMutationMethod<P> extends "POST"
		? { method?: "POST" }
		: { method: RiverMutationMethod<P> });

export type BaseQueryPropsWithInput<P extends RiverQueryPattern> =
	BaseQueryProps<P> & WithOptionalInput<RiverQueryInput<P>>;

export type BaseMutationPropsWithInput<P extends RiverMutationPattern> =
	BaseMutationProps<P> & WithOptionalInput<RiverMutationInput<P>>;

export type RiverRootData = Extract<(typeof routes)[number], { isRootData: true }>["phantomOutputType"];

type RiverFunction = RiverLoader | RiverQuery | RiverMutation;

type RiverPattern = RiverLoaderPattern | RiverQueryPattern | RiverMutationPattern;

export type RiverRouteParams<T extends RiverPattern> =
	Extract<RiverFunction, { pattern: T }> extends { params: infer P }
		? P extends ReadonlyArray<string>
			? P[number]
			: never
		: never;

export const ACTIONS_ROUTER_MOUNT_ROOT = "/api/";

/**********************************************************************
/ River Vite Plugin:
/*********************************************************************/

import type { Plugin } from "vite";

const rollupOptions = {
	input: [
		"frontend/components/routes/dyn.tsx",
		"frontend/components/routes/home.tsx",
		"frontend/components/routes/md.tsx",
		"frontend/entry.tsx",
	] as string[],
	preserveEntrySignatures: "exports-only",
	output: {
		assetFileNames: "river_out_vite_[name]-[hash][extname]",
		chunkFileNames: "river_out_vite_[name]-[hash].js",
		entryFileNames: "river_out_vite_[name]-[hash].js",
	},
} as const;

export const staticPublicAssetMap = {
	"desktop.svg": "river_out_desktop_eebc981612eb.svg",
	"favicon.svg": "river_out_favicon_ed2aaf004a0d.svg",
	"fonts/jetbrains_mono.woff2": "river_out_fonts_jetbrains_mono_1e06740a02a4.woff2",
	"fonts/jetbrains_mono_ext.woff2": "river_out_fonts_jetbrains_mono_ext_7db7affbce1f.woff2",
	"fonts/jetbrains_mono_italic.woff2": "river_out_fonts_jetbrains_mono_italic_6548575d6839.woff2",
	"fonts/jetbrains_mono_italic_ext.woff2": "river_out_fonts_jetbrains_mono_italic_ext_bdce8a4f00f6.woff2",
	"full-logo.svg": "river_out_full-logo_e0ea7a3d3cf2.svg",
	"logo.svg": "river_out_logo_d9b0e1618362.svg",
	"moon.svg": "river_out_moon_7e0c08985ebe.svg",
	"river-banner.webp": "river_out_river-banner_6dfc0fa16366.webp",
	"sun.svg": "river_out_sun_338b26f6045d.svg"
} as const;

export type StaticPublicAsset = keyof typeof staticPublicAssetMap;

declare global {
	function hashedURL(staticPublicAsset: StaticPublicAsset): string;
}

export const publicPathPrefix = "/";

export function waveRuntimeURL(originalPublicURL: keyof typeof staticPublicAssetMap) {
	const url = staticPublicAssetMap[originalPublicURL] ?? originalPublicURL;
	return publicPathPrefix + url;
}

export function riverVitePlugin(): Plugin {
	return {
		name: "river-vite-plugin",
		config(c, { command }) {
			const mp = c.build?.modulePreload;
			const roi = c.build?.rollupOptions?.input;
			const ign = c.server?.watch?.ignored;
			const dedupe = c.resolve?.dedupe;

			const isDev = command === "serve";

			return {
				...c,
				base: isDev ? "/" : "/",
				build: {
					target: "es2022",
					emptyOutDir: false,
					modulePreload: { 
						polyfill: false,
						...(typeof mp === "object" ? mp : {}),
					},
					rollupOptions: {
						...c.build?.rollupOptions,
						...rollupOptions,
						input: [
							...rollupOptions.input,
							...(Array.isArray(roi) ? roi : []),
						],
					},
				},
				server: {
					...c.server,
					headers: {
						...c.server?.headers,
						// ensure versions of dynamic imports without the latest
						// hmr updates are not cached by the browser during dev
						"cache-control": "no-store",
					},
					watch: {
						...c.server?.watch,
						ignored: [
							...(Array.isArray(ign) ? ign : []),
							...[
								"**/*.go",
								"**/app/__dist/**/*",
								"**/backend/__static/**/*",
								"**/wave.config.json",
								"**/frontend/river.gen.ts",
								"**/frontend/routes.ts"
							],
						],
					},
				},
				resolve: {
					...c.resolve,
					dedupe: [
						...(Array.isArray(dedupe) ? dedupe : []),
						...["solid-js","solid-js/web"]
					],
				},
			};
		},
		transform(code, id) {
			const isNodeModules = /node_modules/.test(id);
			if (isNodeModules) return null;
			const assetRegex = /hashedURL\s*\(\s*(["'`])(.*?)\1\s*\)/g;
			const needsReplacement = assetRegex.test(code);
			if (!needsReplacement) return null;
			const replacedCode = code.replace(
				assetRegex,
				(_, __, assetPath) => {
					const hashed = (staticPublicAssetMap as Record<string, string>)[assetPath];
					if (!hashed) return `"${assetPath}"`;
					return `"/${hashed}"`;
				},
			);
			if (replacedCode === code) return null;
			return replacedCode;
		},
	};
}
