/**********************************************************************
/ Generated by tsgen. DO NOT EDIT.
/*********************************************************************/

/**********************************************************************
/ Collection:
/*********************************************************************/

const routes = [
	{
		_type: "loader",
		isRootData: true,
		params: [],
		pattern: "/",
		phantomOutputType: null as unknown as RootData,
	},
	{
		_type: "loader",
		params: ["dyn"],
		pattern: "/__/:dyn",
		phantomOutputType: null,
	},
	{
		_type: "loader",
		params: [],
		pattern: "/*",
		phantomOutputType: null as unknown as DetailedPage,
	},
	{
		_type: "loader",
		params: [],
		pattern: "/_index",
		phantomOutputType: null as unknown as string,
	},
] as const;

/**********************************************************************
/ Ad Hoc Types:
/*********************************************************************/

export type DetailedPage = {
	Title?: string;
	Description?: string;
	Date?: string;
	Content?: string;
	URL?: string;
	IsFolder?: boolean;
	Sitemap: Array<SitemapItem>;
	IndexSitemap: Array<SitemapItem>;
	BackItem: string;
};

export type RootData = {
	LatestVersion: string;
};

export type Sitemap = Array<SitemapItem>;

export type SitemapItem = {
	title: string;
	url: string;
	isActive?: boolean;
};

/**********************************************************************
/ Extra TS Code:
/*********************************************************************/

export type RiverLoader = Extract<(typeof routes)[number], { _type: "loader" }>;
export type RiverLoaders = { [K in RiverLoaderPattern]: Extract<RiverLoader, { pattern: K }>; };
export type RiverLoaderPattern = RiverLoader["pattern"];
export type RiverLoaderOutput<T extends RiverLoaderPattern> = Extract<RiverLoader, { pattern: T }>["phantomOutputType"];

export type RiverRootData = Extract<(typeof routes)[number], { isRootData: true }>["phantomOutputType"];
type RiverFunction = RiverLoader;
type RiverPattern = RiverLoaderPattern;
export type RiverRouteParams<T extends RiverPattern> = (Extract<RiverFunction, { pattern: T }>["params"])[number];

export const ACTIONS_ROUTER_MOUNT_ROOT = "/api/";

/**********************************************************************
/ River Vite Plugin:
/*********************************************************************/

import type { Plugin } from "vite";

const rollupOptions = {
	input: [
		"frontend/components/routes/dyn.tsx",
		"frontend/components/routes/home.tsx",
		"frontend/components/routes/md.tsx",
		"frontend/entry.tsx",
	] as string[],
	preserveEntrySignatures: "exports-only",
	output: {
		assetFileNames: "river_out_[name]-[hash][extname]",
		chunkFileNames: "river_out_[name]-[hash].js",
		entryFileNames: "river_out_[name]-[hash].js",
	},
} as const;

export const staticPublicAssetMap = {
	"desktop.svg": "desktop_eebc981612eb.svg",
	"favicon.svg": "favicon_ed2aaf004a0d.svg",
	"full-logo.svg": "full-logo_e0ea7a3d3cf2.svg",
	"logo.svg": "logo_d9b0e1618362.svg",
	"moon.svg": "moon_7e0c08985ebe.svg",
	"river-banner.webp": "river-banner_6dfc0fa16366.webp",
	"sun.svg": "sun_338b26f6045d.svg"
} as const;

export type StaticPublicAsset = keyof typeof staticPublicAssetMap;

declare global {
	function hashedURL(staticPublicAsset: StaticPublicAsset): string;
}

export const publicPathPrefix = "/public/";

export function waveRuntimeURL(originalPublicURL: keyof typeof staticPublicAssetMap) {
	const url = staticPublicAssetMap[originalPublicURL] ?? originalPublicURL;
	return publicPathPrefix + url;
}

export function riverVitePlugin(): Plugin {
	return {
		name: "river-vite-plugin",
		config(c, { command }) {
			const mp = c.build?.modulePreload;
			const roi = c.build?.rollupOptions?.input;
			const ign = c.server?.watch?.ignored;
			const dedupe = c.resolve?.dedupe;

			const isDev = command === "serve";

			return {
				...c,
				base: isDev ? "/" : "/public/",
				build: {
					target: "es2022",
					...c.build,
					emptyOutDir: false,
					modulePreload: { 
						polyfill: false,
						...(typeof mp === "object" ? mp : {}),
					},
					rollupOptions: {
						...c.build?.rollupOptions,
						...rollupOptions,
						input: [
							...rollupOptions.input,
							...(Array.isArray(roi) ? roi : []),
						],
					},
				},
				server: {
					...c.server,
					headers: {
						...c.server?.headers,
						// ensure versions of dynamic imports without the latest
						// hmr updates are not cached by the browser during dev
						"cache-control": "no-store",
					},
					watch: {
						...c.server?.watch,
						ignored: [
							...(Array.isArray(ign) ? ign : []),
							...[
								"**/*.go",
								"**/__dist/**/*",
								"**/backend/__static/**/*",
								"**/wave.config.json",
								"**/frontend/river.gen.ts",
								"**/frontend/routes.ts"
							],
						],
					},
				},
				resolve: {
					...c.resolve,
					dedupe: [
						...(Array.isArray(dedupe) ? dedupe : []),
						...["solid-js","solid-js/web"]
					],
				},
			};
		},
		transform(code, id) {
			const isNodeModules = /node_modules/.test(id);
			if (isNodeModules) return null;
			const assetRegex = /hashedURL\s*\(\s*(["'`])(.*?)\1\s*\)/g;
			const needsReplacement = assetRegex.test(code);
			if (!needsReplacement) return null;
			const replacedCode = code.replace(
				assetRegex,
				(_, __, assetPath) => {
					const hashed = (staticPublicAssetMap as Record<string, string>)[assetPath];
					if (!hashed) return '\"' + assetPath + '\"';
					return `"/public/${hashed}"`;
				},
			);
			if (replacedCode === code) return null;
			return replacedCode;
		},
	};
}
