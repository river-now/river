package router

import (
	"errors"
	"fmt"
	"net/http"

	"github.com/river-now/river/kit/mux"
	"github.com/river-now/river/kit/validate"
)

var ActionsRouter = mux.NewRouter(&mux.Options{
	MountRoot: "/api/",
	ParseInput: func(r *http.Request, iPtr any) error {
		// include other methods as needed
		if r.Method == http.MethodGet {
			return validate.URLSearchParamsInto(r, iPtr)
		}
		if r.Method == http.MethodPost {
			return validate.JSONBodyInto(r, iPtr)
		}
		return errors.New("unsupported method")
	},
})

type ActionCtx[I any] struct {
	*mux.ReqData[I]
	// Anything else you want available on the ActionCtx
}

func NewAction[I any, O any](method, pattern string, f func(c *ActionCtx[I]) (O, error)) *mux.TaskHandler[I, O] {
	wrappedF := func(c *mux.ReqData[I]) (O, error) {
		return f(&ActionCtx[I]{
			ReqData: c,
			// Anything else you want available on the ActionCtx
		})
	}
	actionTask := mux.TaskHandlerFromFunc(wrappedF)
	mux.RegisterTaskHandler(ActionsRouter, method, pattern, actionTask)
	return actionTask
}

/////// EXAMPLES

const UsernameMaxLen = 42

var count = 0
var username = "guest"

var _ = NewAction("POST", "/increment-count", func(c *ActionCtx[mux.None]) (int, error) {
	count++
	return count, nil
})

type UsernameInput struct {
	Username string `json:"username"`
}

func (i *UsernameInput) Validate() error {
	if i.Username == "" {
		return errors.New("username is required")
	}
	if len(i.Username) > UsernameMaxLen {
		return fmt.Errorf("username must be at most %d characters", UsernameMaxLen)
	}
	return nil
}

var _ = NewAction("POST", "/set-username", func(c *ActionCtx[UsernameInput]) (string, error) {
	username = c.Input().Username
	return username, nil
})
